获取通过`scanf("%s", a)`读入的**字符数组**的长度`size_t strlen (const char *)`，头文件`string.h`

---

16转2：

```c
char xtob(char a)
{
    char bin;
    a -= 0x30;
    if (a > 0xA) a -= 0x7;
    return a;
}
```

---

运行完后 `a[2]==3`：

```c
int a[10] = {0};
int i=1;
a[i] = i++ + i;
```

---

scanf读取字符串的长度有上限：4095（ubuntu环境下）

原因：受限于缓冲区大小

> [参考](https://www.coder.work/article/178119)

这道题（[BASIC-12 十六进制转八进制](http://lx.lanqiao.cn/problem.page?gpid=T51)）的问题不在于读取的字符太长，而在于申请的空间（10*10w的数组）太多，导致**运行时错误**！

该题应该是**分组输入**，每输入一组数据，就输出一个结果。这样就不用初始化10个数组，只需要初始化1个。